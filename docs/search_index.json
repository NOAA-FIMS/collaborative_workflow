[["index.html", "FIMS Developer Handbook Chapter 1 About 1.1 Usage 1.2 Render book 1.3 Preview book", " FIMS Developer Handbook FIMS implementation team 2022-01-11 Chapter 1 About This is a book written in Markdown describing the FIMS development workflow. This section describes how to edit and contribute to the book. 1.1 Usage Each bookdown chapter is an .Rmd file, and each .Rmd file can contain one (and only one) chapter. A chapter must start with a first-level heading: # A good chapter, and can contain one (and only one) first-level heading. Use second-level and higher headings within chapters like: ## A short section or ### An even shorter section. The index.Rmd file is required, and is also your first book chapter. It will be the homepage when you render the book. 1.2 Render book You can render the HTML version of this example book without changing anything: Find the Build pane in the RStudio IDE, and Click on Build Book, then select your output format, or select “All formats” if you’d like to use multiple formats from the same book source files. Or build the book from the R console: bookdown::render_book() To render this example to PDF as a bookdown::pdf_book, you’ll need to install XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.org/tinytex/. 1.3 Preview book As you work, you may start a local server to live preview this HTML book. This preview will update as you edit the book when you save individual .Rmd files. You can start the server in a work session by using the RStudio add-in “Preview book”, or from the R console: bookdown::serve_book() "],["code-of-conduct.html", "Chapter 2 Code of Conduct 2.1 FIMS Contributor Conduct 2.2 Ensuring Good Conduct", " Chapter 2 Code of Conduct 2.1 FIMS Contributor Conduct All contributors participating and contributing to the FIMS project are expected to adhere to the Contributor Covenant. Briefly, these standards are adopted to ensure a positive and harassment-free enviroment for all participants. Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community 2.2 Ensuring Good Conduct FIMS Community leaders will create default community health files (e.g. CONTRIBUTING, CODE_OF_CONDUCT) to be used in all repositories owned by FIMS. 2.2.1 Questions or Reporting Unacceptable Behavior For questions about the FIMS Code of Conduct, or to report unacceptable behavior, contact the FIMS Community leaders at [INSERT FIMS EMAIL WHEN AVAILABLE]. All inquiries and reports will be reviewed promptly and fairly. "],["style-guide.html", "Chapter 3 Style Guide", " Chapter 3 Style Guide The FIMS project uses style guides to ensure our code is consistent, easy to use (e.g. read, share, and verify), and ultimately easier to write. We use the Google C++ Style Guide and Google’s R Style Guide. Google’s R Style Guide is based off of the tidyverse style guide, with a few minor modifications to improve readability and portability. "],["contributor-guidelines.html", "Chapter 4 Contributor Guidelines 4.1 FIMS Branching Strategy 4.2 Issue Tracking 4.3 Pull Requests 4.4 Coding Good Practices 4.5 Commit Messages 4.6 Code Review 4.7 External Collaborators", " Chapter 4 Contributor Guidelines External contributions and feedback are important to the development and future maintenance of FIMS and are welcome. This section provides information for FIMS developers and collaborators on how to contribute to the project. 4.1 FIMS Branching Strategy There are several branching strategies available that will work within the Git environment and other version control systems. However, it is important to find a strategy that works well for both current and future contributors. Branching strategies provide guidance for how, when, and why branches are created and named, which also ties into necessary guidance surrounding issue tracking. The FIMS Project uses a Scaled Trunk Based Development branching strategy to make tasks easier without compromising quality. This strategy is required for continuous integration and facilitates knowledge of steps that must be taken prior to, during, and after making changes to the code, while still allowing anyone interested in the code to read it at any time. Additionally, trunk-based development captures the following needs without being overly complicated: Short-lived branches to minimize stale code and merge conflicts Fast release times, especially for bug fixes Ability to release bug fixes without new features 4.1.1 Branching Good Practices The following suggestions will help ensure optimal performance of the trunk-based branching strategy: Branches and commits should be kept small (e.g. a couple commits, a few lines of code) to allow for rapid merges and deployments. Use feature flags to wrap new changes in an inactive code path for later activation (rather than creating a separate repository feature branch). Delete branches after it is merged to the trunk; avoid repositories with a large number of “active” branches. Merge branches to the trunk frequently (e.g. at least every few days; tag as a release commit) to avoid merge conflicts. Use caching layers where appropriate to optimize build and test execution times. 4.1.2 Branch Protection Branch protection allows for searching branch names with grep functionality to apply merging rules (i.e., protection). This will be helpful to protect the main/trunk branch such that pull requests cannot be merged in prior to passing various checks or by individuals without the authority to do so. 4.2 Issue Tracking Use of the GitHub issue tracker is key to keeping everyone informed and prioritizing key tasks. All future projects, ideas, concerns, development, etc. must be documented in an issue before the code is altered. Issues should be filed and tagged prior to any code changes whether the change pertains to a bug or the development of a feature. At a minimum, all issues will be labeled with a future version number. Bugs with immediate fixes will be assigned to the current version number augmented for a hot fix and development will be based on code in the trunk. All other issues will be assigned to a future version and development will be based on version branches. That is, changes to the code for version 3.3 cannot start until there is a branch for version 3.3. This will minimize stale code and large merge conflicts. 4.2.1 Issue Templates To be developed (e.g. report bug, request enhancement, maintenance/feature dev)… 4.3 Pull Requests Pull requests are used to identify changes pushed to development branches. Open pull requests allow the FIMS Development Team to discuss and review the changes, as well as add follow-up commits before merging to the main branch. As noted above in the branching stratgegy section, branches, commits, and pull requests should be kept small to enable rapid review and reduce the chance of merge conflicts. Any pull requests for the FIMS Project must be fully tested and reviewed before being merged into the main branch. 4.4 Coding Good Practices Following good software development and coding practices simplifies collaboration, improves readability, and streamlines testing and review. The following are industry-accepted standards: Adhere to the FIMS Project style guide Avoid rework - take the time to check for existing options (e.g. in-house, open source, etc.) before writing code Keep code as simple as possible Use meaningful variable names that are easy to understand and clearly represent the data they store Use descriptive titles and consistent conventions for class and function names Use consistent names for temporary variables that have the same kind of role Add clear and concise coding comments Use consistent formatting and indentation to improve readability and organization Group code into separate blocks for individual tasks Avoid hard-coded values to ensure portability of code Follow the DRY principle - “Don’t Repeat Yourself” (or your code) Avoid deep nesting Limit line length (wrap ~72 characters) Capitalize SQL queries so they are readily distinguishable from table/column names 4.5 Commit Messages FIMS Project contributors should provide clear, descriptive commit messages to communicate to collaborators details about changes that have occurred and improve team efficiency. Good commit messages follow the following practices: Include a short summary of the change for the subject/title (&lt;50 characters) Include a blank line in between the ‘subject’ and ‘body’ Specify the type of commit: * fix: bug fix * feat: new feature * test: testing * docs: documentation * chore: regular code maintenance (e.g. updating dependencies) * refactor: refactoring codebase * style: changes that do not affect the meaning of the code; instead address code styling/formmatting * perf: performance improvements * revert: reverts a previous commit * build: changes that affect the build system If the commit addresses an issue, indicate the issue# in the title Provide a brief explanatory description of the change, addressing what and why was changed Wrap to ~72 characters Write in the imperative (e.g. “Fix bug”, not “Fixed bug”) If necessary, separate paragraphs by blank lines Utilize BREAKING CHANGE: &lt;description&gt; to provide expanation or further context about the issue being addressed. If the commit closes an issue, include a footer to note that (i.e. “Closes #19”) 4.6 Code Review Code review ensures health and continuous improvement of the FIMS codebase, while simultaneously helping FIMS developers become familiar with the codebase and ensure there is a diverse team of knolwedgable collaborators to support the continued development and maintenance of FIMS. CI/CD requires rapid review of all new/modified code, so processes must be in place to support this pace. FIMS code review will utilize tools available via GitHub, which allows reviewers to analyze code changes, provide inline comments, and view change histories. 4.6.1 Assigning Reviewers Reviewers for the FIMS Project may be assigned in two different ways: A specific member of the FIMS Development Team is requested to review a pull request, based on their specific expertise. Code review assignments are automatically assigned using the GitHub load balance routing algorithm; this approach tries to ensure that each team member reviews an equal number of pull request in any 30 day period. Team members should keep their status in Github current (see “Setting a status” for more information). Reviews will not be auto-assigned to “Busy” team members. If a review has been assigned to you and you don’t feel like you have the expertise to address it properly, please respond directly to the code owner immediately so a different reviewer can be found promptly. 4.6.2 Automated Testing Automated testing provides an initial layer of quality assurance and lets reviewers know that the code meets certain standards. For more on FIMS testing, see Chapter 6. 4.6.3 Review Criteria While automated testing can assure the code structure and logic pass quality checks, human reviewers are required to evaluate things like functionality, readability, etc. Reviewers should evaluate the code critically and provide comment/feedback on the following items: Readability * Is the code easy to understand? * Are there any parts of the code that are confusing? * Is the data flow easy to understand? * Is there any code commented out? * Does the code include any unclear names? * Does the code include any errors, repeats, or incomplete sections? Functionality * Does the code function as it is expected to? * How will the change impact other parts of the system? * Are there any unhandled edge cases? * Are there other code improvements possible? Design * Are files organized intuitively? * Are components divided up in a sensible way? * Does the review include too many changes? Would the code change better be broken into more focused parts? * Will the change be easy to maintain? * Does the code follow object-oriented design principles? * Is the code in the proper location? Security * Does using this code open the software to possible security violations or vulnerabilities? * Is the correct encryption used? Performance * Are there ways to improve on the code’s performance? * Is there any complex logic that could be simplified? * Could any of the code be replaced with built-in functions? * Will this change have any impacts on system performance? * Is there any debugging code that could be removed? * Are there any optimizations that could be removed and still maintain system performance? Documentation * Are there comments available to explain the code? * Is the README file complete and current? Does it adequately describe the project/changes? Testing * Is the code testable? * Is the automated testing adequate? * Have dependencies been appropriately tested? * Does automated testing cover the code exchange adequately? * Could the test structure be improved? 4.6.4 Review Good Practices Good reviews require good review habits. Try to follow these suggestions: Review in short sessions (&lt; 60 minutes) to maintain focus and attention to detail Don’t try to review more than 400 lines of code in a single session Provide constructive and supportive feedback * Ask open-ended questions and offer alternatives or possible workarounds * Avoid strong/opinionated statements * Applaud good solutions * Don’t say “you” Be clear about which questions/comments are non-blocking or unimportant; likewise, be explicit when approving a change or requesting follow-up * Aim to minimize the number of nitpicks (if there are a lot, suggest a team-level resolution) Use the FIMS Style Guide to settle any style arguments 4.7 External Collaborators External collaborators interested in contributing to FIMS development are required to fork the FIMS repository, make changes, and submit a pull request. However, collaborators are strongly encouraged to submit an issue via the main FIMS repository for discussion prior to forking. In general, forks are discouraged for everyday development as it becomes difficult to keep track of multiple forks. Pull requests from forks will be reviewed the same as a pull request submitted from a branch. Users will need to conform to the same standards and all contributions must pass the standard tests as well as provide tests that check the new feature. "],["hpp-template-for-c-modules.html", "Chapter 5 .hpp template for C++ modules", " Chapter 5 .hpp template for C++ modules In this section we will describe how to structure a new .hpp file in FIMS. "],["test-case-template.html", "Chapter 6 Test case template 6.1 Introduction 6.2 C++ unit testing and benchmarking 6.3 R testing 6.4 Test case template and examples 6.5 Glossary", " Chapter 6 Test case template [Work in progress] In this section we will describe how to write a test case for your FIMS code. 6.1 Introduction FIMS testing framework will include different types of testing to make sure that changes to FIMS code are working as expected. The unit and functional tests will be developed during the initial development stage when writing individual functions or modules. After completing development of multiple modules, integration testing will be developed to verify that different modules work well together. Checks will be added in the software to catch user input errors when conducting run-time testing. Regression testing and platform compatibility testing will be executed before pre-releasing FIMS. Beta-testing will be used to gather feedback from users (i.e. Members of FIMS implementation team and other users) during the pre-releasing stage. After releasing the first version of FIMS, the team will go back to the beginning of the testing cycle and write unit tests when a new feature needs to be implemented. One-off testing will be used for fixing user-reported bugs when maintaining FIMS. More details of each type of test can be found in the Glossary section. FIMS will use GoogleTest to build a C++ unit testing framework and R testthat to build an R testing framework. FIMS will use Google Benchmark to measure the real time and CPU time used for running the produced binaries. 6.2 C++ unit testing and benchmarking 6.2.1 Requirements To use GoogleTest, you will need: A compatible operating system (e.g. Windows, masOS, or Linux). A C++ compiler that supports at least C++ 11 standard or newer (e.g. gcc 5.0+, clang 5.0+, or MSVC 2015+). For macOS users, Xcode 9.3+ provides clang 5.0. A build system for building the testing project. CMake and a compatible build tool such as Ninja are approved softwares by NMFS HQ. 6.2.2 Quickstart for Windows user Download CMake 3.22.1 (cmake-3.22.1-windows-x86_64.zip) and put the file folder to Documents\\Apps or other preferred folder. Download ninja v1.10.2 (ninja-win.zip) and put the application to Documents\\Apps or other preferred folder. Search Edit environment variables for your account and open the Environment Variables window. Click Edit... under the User variables for firstname.lastname section. Click New, add path to cmake-3.21.4-windows-x86_64\\bin, add click OK. Click New, add path to Documents\\Apps, add click OK. Open your Command Prompt and type cmake. If you see details of usage, you install the build system successfully. See CMake installation instructions for installing CMake on other platforms. 6.2.3 Set up FIMS testing project Go to the FIMS C++ tests folder and create a CMakeLists.txt file. Declare a dependency on GoogleTest with following contents: cmake_minimum_required(VERSION 3.14) project(FIMS_project) # GoogleTest requires at least C++11 set(CMAKE_CXX_STANDARD 11) include(FetchContent) FetchContent_Declare( googletest URL https://github.com/google/googletest/archive/refs/tags/release-1.11.0.zip ) # For Windows: Prevent overriding the parent project&#39;s compiler/linker settings set(gtest_force_shared_crt ON CACHE BOOL &quot;&quot; FORCE) FetchContent_MakeAvailable(googletest) If a CMakeLists.txt file already exists in the tests folder, you can start creating a unit test and add it to the CMakeLists.txt. 6.2.4 Unit test template #include &quot;gtest/gtest.h&quot; #include &quot;../src/code.hpp&quot; // # R code that generates true values for the test namespace { // Description of Test 1 TEST(TestSuiteName, Test1Name) { ... test body ... } // Description of Test 2 TEST(TestSuiteName, Test2Name) { ... test body ... } } 6.2.5 Unit test example Let’s create dlognorm.hpp that has a simple function: #include &lt;cmath&gt; template&lt;class Type&gt; Type dlognorm(Type x, Type meanlog, Type sdlog){ Type resid = (log(x)-meanlog)/sdlog; Type logres = -log(sqrt(2*M_PI)) - log(sdlog) - Type(0.5)*resid*resid - log(x); return logres; } We can create a test file dlognorm-unit.cpp that has a test suite for this function: #include &quot;gtest/gtest.h&quot; #include &quot;../src/dlognorm.hpp&quot; // # R code that generates true values for the test // dlnorm(1.0, 0.0, 1.0) = -0.9189385 // dlnorm(5.0, 10.0, 2.5) = -9.07679 namespace { // TestSuiteName: dlognormTest; TestName: DoubleInput and IntInput // Test dlognorm with double input values TEST(dlognormTest, DoubleInput) { EXPECT_NEAR( dlognorm(1.0, 0.0, 1.0) , -0.9189385 , 0.0001 ); EXPECT_NEAR( dlognorm(5.0, 10.0, 2.5) , -9.07679 , 0.0001 ); } // Test dlognorm with integer input values TEST(dlognormTest, IntInput) { EXPECT_NE( dlognorm(1, 0, 1) , -0.9189385 ); } } EXPECT_NEAR(val1, val2, absolute_error) verifies that the difference between val1 and val2 does not exceed the absolute error bound absolute_error. EXPECT_NE(val1, val2) verifies that val1 is not equal to val2. Please see GoogleTest assertions reference for more EXPECT_ macros. 6.2.6 Add tests to CMakeLists.txt and run a binary To build the code, add the following contents to the end of your CMakeLists.txt file: enable_testing() add_executable( dlognorm_test dlognorm-unit.cpp ) target_include_directories( dlognorm_test PUBLIC ${CMAKE_SOURCE_DIR}/../ ) target_link_libraries( dlognorm_test gtest_main ) include(GoogleTest) gtest_discover_tests(dlognorm_test) The above configuration enables testing in CMake, declares the C++ test binary you want to build (dlognorm_test), and links it to GoogleTest (gtest_main). Now you can build and run your test: cd tests cmake -S . -B build -G Ninja cd build cmake --build . ctest The output might look like this: Start 1: dlognormTest.DoubleInput 1/2 Test #1: dlognormTest.DoubleInput ......... Passed 0.36 sec Start 2: dlognormTest.IntInput 2/2 Test #2: dlognormTest.IntInput ............ Passed 0.01 sec 100% tests passed, 0 tests failed out of 2 Total Test time (real) = 0.37 sec Congratulations! You’ve successfully set up a test project and run a test binary using GoogleTest. Let’s use Google Benchmark to measure the real time and CPU time used for running the produced binary. 6.2.7 Benchmark template #include &quot;benchmark/benchmark.h&quot; #include &quot;../src/code.hpp&quot; void BM_FunctionName(benchmark::State&amp; state) { for (auto _ : state) // This code gets timed Function() } // Register the function as a benchmark BENCHMARK(BM_FunctionName); 6.2.8 Benchmark example We will continue using the dlognorm.hpp example. We can create a benchmark file dlognorm_benchmark.cpp and put it in the tests folder: #include &quot;benchmark/benchmark.h&quot; #include &quot;../src/dlognorm.hpp&quot; void BM_dlgnorm(benchmark::State&amp; state) { for (auto _ : state) dlognorm(5.0, 10.0, 2.5); } BENCHMARK(BM_dlgnorm); Please see more examples on Google Benchmark GitHub repository for a more comprehensive feature overview. 6.2.9 Add benchmarks to CMakeLists.txt and run the benchmark To build the code, add the following contents to the end of your CMakeLists.txt file: FetchContent_Declare( googlebenchmark URL https://github.com/google/benchmark/archive/refs/tags/v1.6.0.zip ) FetchContent_MakeAvailable(googlebenchmark) add_executable( dlognorm_benchmark dlognorm_benchmark.cpp ) target_include_directories( dlognorm_benchmark PUBLIC ${CMAKE_SOURCE_DIR}/../ ) target_link_libraries( dlognorm_benchmark benchmark_main ) To run the benchmark, cd build ./dlognorm_benchmark.exe The output might look like this: ***WARNING*** Library was built as DEBUG. Timings may be affected. ---------------------------------------------------------------- Benchmark Time CPU Iterations ---------------------------------------------------------------- BM_dlgnorm 128 ns 126 ns 5600000 6.3 R testing FIMS uses R testthat package for writing R tests. You can install the packages following the instructions on testthat website. If you are not familiar with testthat, the testing chapter in R packages gives a good overview of testing workflow, along with structure explanation and concrete examples. 6.3.1 R testthat template test_that(&quot;TestName&quot;, { ...test body... }) 6.4 Test case template and examples 6.4.1 Test case template Individual functional or integration test cases will be designed following the template below. Test ID. Create a meaningful name for the test case. Features to be tested. Provide a brief statement of test objectives and description of the features to be tested. (Identify the test items following the FIMS software design specification document and identify all features that will not be tested and the rationale for exclusion) Approach. Specify the approach that will ensure that the features are adequately tested and specify which type of test is used in this case. Evaluation criteria. Provide a list of expected results and acceptance criteria. Pass/fail criteria. Specify the criteria used to determine whether each feature has passed or failed testing. In addition to setting pass/fail criteria with specific tolerance values, a documentation that just views the outputs of some tests may be useful if the tests require additional computations, simulations, and comparisons Test deliverables. Identify all information that is to be delivered by the test activity. Test logs and automated status reports 6.4.2 Test case examples 6.4.2.1 General test case The test case below is a general case and it can be applied to many functions/modules. For individual functions/modules, please make detailed test cases for specific options to avoid duplication as much as possible. Test ID General test case Features to be tested The function/module returns correct output values given different input values The function/module returns error messages when users give wrong types of inputs The function/module notifies an error if the input value is outside the bound of the input parameter Approach Prepare expected true values using R Run tests in R using testthat and compare output values with expected values Push tests to the working repository and run tests using GitHub Actions Run tests in different OS environments (windows latest, macOS latest, and ubuntu latest) using GitHub Actions Submit pull request for code review Evaluation Criteria The tests pass if the output values equal to the expected true values The tests pass if the function/module returns error messages when users give wrong types of inputs The tests pass if the function/module returns error messages when user provides an input value that is outside the bound of the input parameter Test deliverables Test logs on GitHub Actions 6.4.2.2 Functional test example: TMB probability mass function of the multinomial distribution Test ID Probability mass function of the multinomial distribution Features to be tested Same as the general test case Approach Functional test Prepare expected true values using R function dmultinom from package ‘stats’ Evaluation Criteria Same as the general test case Test deliverables Same as the general test case 6.4.2.3 Integration test example: Li et al. 2021 age-structured stock assessment model comparison Test ID Age-structured stock assessment comparison (Li et al. 2021) Features to be tested Null case (update standard deviation of the log of recruitment from 0.2 to 0.5 based on Siegfried et al. 2016 snapper-grouper complex) Recruitment variability Stochastic Fishing mortality (F) F patterns (e.g., roller coaster: up then down and down then up; constant Flow, FMSY, and Fhigh) Selectivity patterns Recruitment bias adjustment Initial condition (unit of catch: number or weight) Model misspecification (e.g., growth, natural mortality, and steepness, catchability etc) Approach Integration test Prepare expected true values from an operating model using R functions from Age_Structured_Stock_Assessment_Model_Comparison GitHub repository Evaluation Criteria Summarize median absolute relative error (MARE) between true values from the operating model and the FIMS estimation model If all MAREs from the null case are less than 10% and all MARES are less than 15%, the tests pass. If the MAREs are greater than 15%, a closer examination is needed. Test deliverables In addition to the test logs on GitHub Actions, a document that includes comparison figures from various cases (e.g., Fig 5 and 6 from Li et al. 2021) will be automatically generated A table that shows median absolute relative errors in unfished recruitment, catchability, spawning stock biomass, recruitment, fishing mortality, and reference points (e.g., Table 6 from Li et al. 2021) will be automatically generated 6.5 Glossary 6.5.1 Unit testing Description: It tests individual methods and functions of the classes, components or modules used by the software independently. It executes only small portions of the test cases during the development process. Writer: Developer Advantages: It finds problems early and helps trace the bugs in the development cycle; cheap to automate when a method has clear input parameters and output; can be run quickly. Limitations: Tedious to create; it won’t catch integration errors if a method or a function has interactions with something external to the software. Examples: A recruitment module may consist of a few stock-recruit functions. We could use a set of unit test cases that ensure each stock-recruit function is correct and meets its design as intended while developing the function. Reference: Wikipedia description 6.5.2 Functional testing Description: It checks software’s performance with respect to its specified requirements. Testers do not need to examine the internal structure of the piece of software tested but just test a slice of functionality of the whole system after it has been developed. Writer: Tester Advantages: It verifies that the functionalities of the software are working as defined; lead to reduced developer bias since the tester has not been involved in the software’s development. Limitations: Need to create input data and determine output based on each function’s specifications; need to know how to compare actual and expected outputs and how to check whether the software works as the requirements specified. Examples: The software requires development of catch-based projection. We could use a set of functional test cases that help verify if the model produces correct output given specified catch input after catch-based projection has been implemented in the system. Reference: Wikipedia description; WHAM testthat examples 6.5.3 Integration testing Description: A group of software modules are coupled together and tested. Integrate software modules all together and verify the interfaces between modules against the software design. It is tested until the software works as a system. Writer: Tester Advantages: It builds a working version of the system by putting the modules together. It assembles a software system and helps detect errors associated with interfacing. Limitations: The tests only can be executed after all the modules are developed. It may be difficult to locate errors because all components are integrated together. Examples: After developing all the modules, we could set up a few stock assessment test models and check if the software can read the input file, run the stock assessment models, and provide desired output. Reference: Wikipedia description 6.5.4 Run-time testing Description: Checks added in the software that catch user input errors. The developer will add in checks to the software; the user will trigger these checks if there are input errors Writer: developer Advantages: Provides guidance to the user while using the software Limitations: Adding many checks can cause the software to run more slowly, the messages need to be helpful so the user can fix the input error. Examples: A user inputs a vector of values when they only need to input a single integer value. When running the software, they get an error message telling them that they should use a single integer value instead. Reference: Testing R code book 6.5.5 Regression testing Description: Re-running tests to ensure that previously developed and tested software still performs after a change. Testers can execute regression testing after adding a new feature to the software or whenever a previously discovered issue has been fixed. Testers can run all tests or a part of the test suite to check the correctness or quality of the software. Writer: Tester Advantages: It ensures that the changes made to the software have not affected the existing functionalities or correctness of the software. Limitations: If the team makes changes to the software often, it may be difficult to run all tests from the test suite frequently. In that case, it’s a good idea to have a regression testing schedule. For example, run a part of the test suite that is higher in priority after every change and run the full test suite weekly or monthly, etc. Examples: Set up a test suit like the ss-test-models repository. The test cases can be based on real stock assessment models, but may not be the final model version or may have been altered for testing purposes. Test the final software by running this set of models and seeing if the same results for key model quantities remain the same relative to a “reference run” (e.g., the last release of the software). Reference: Wikipedia description 6.5.6 Platform compatibility testing Description: It checks whether the software is capable of running on different operating systems and versions of other softwares. Testers need to define a set of environments or platforms the application is expected to work on. Testers can test the software on different operating systems or platforms and report the bugs. Writer: Tester Advantages: It ensures that the developed software works under different configurations and is compatible with the client’s environment. Limitations: Testers need to have knowledge of the testing environment and platforms to understand the expected software behavior under different configurations. It may be difficult to figure out why the software produces different results when using different operating systems. Examples: Set up an automated workflow and see if the software can be compatible with different operating systems, such as Windows, macOS, and Linux. Also, testers can check if the software is compatible with different versions of R (e.g., release version and version 3.6, etc). Reference: International Software Testing Qualification Board 6.5.7 Beta testing Description: It is a form of external user acceptance testing and the feedback from users can ensure the software has fewer bugs. The software is released to a limited end-users outside of the implementation team and the end-users (beta testers) can report issues of beta software to the implementation team after further testing. Writer: Members of implementation team and other users Advantages: It helps in uncovering unexpected errors that happen in the client’s environment. The implementation team can receive direct feedback from users before shipping the software to users. Limitations: The testing environment is not under the control of the implementation team and it may be hard to reproduce the bugs. Examples: Prepare a document that describes the new features of the software and share it with selected end-users. Send a pre-release of the software to selected users for further testing and gather feedback from users. Reference: Wikipedia description; SS prerelease example 6.5.8 One-off testing Description: It is for replicating and fixing user-reported bugs. It is a special testing that needs to be completed outside of the ordinary routine. Testers write a test that replicates the bug and run the test to check if the test is failing as expected. After fixing the bug, the testers can run the test again and check if the test is passing. Writer: Developer and tester Advantages: The test is simple, fast, and efficient for fixing bugs. Limitations: The tests are specific to bugs and may require manual testing. Examples: A bug is found in the code and the software does not work properly. Tester can create a test to replicate the bug and the test would fail as expected. After the developer fixes the bug, the tester can run the test and see if the issue is resolved. Reference: International Software Testing Qualification Board; SS bug fix example "],["documentation-template.html", "Chapter 7 Documentation template", " Chapter 7 Documentation template In this section we will describe how to document your code. For more information about code documentation in general, please see the toolbox blog post here. This post describes the differences between the types of documentation, while below we give specific, brief instructions on developer responsibilities for FIMS. "],["writing-function-reference.html", "Chapter 8 Writing function reference", " Chapter 8 Writing function reference Function reference can be written inline in comments above the function in either C++ or R. The tools you can use to generate reference from comments are called Doxygen and Roxygen in C++ and R respectively. Both can include LaTeX syntax to denote equations, and both use @ tags to name components of the function reference {c eval=FALSE} / (???) This function calculates the von Bertalanffy growth curve. * \\f$ * * length_at_age = lmin + (lmax - lmin) * \\f$ * * (???) age * (???) sex * (???) length_at_age / ** The only difference between syntax for R and C++ code is how comments are denoted in the language. {r eval=FALSE} #’ This function calculates the von Bertalanffy growth curve. #’ #’ (???) age #’ (???) sex #’ (???) length_at_age You should, at minimum, include the tags (???), (???), and (???) in your function reference if it is an exported function. Functions that are only called internally do not require an (???) tag. Other useful tags include (???) and (???) for Roxygen chunks. "],["writing-a-vignette.html", "Chapter 9 Writing a vignette", " Chapter 9 Writing a vignette If this is an exported function, a vignette can be a helpful tool to users to know how to use your function. If you include a vignette for your function, you can link to it in the Roxygen documentation with the following code. {r eval=FALSE} #’ # Step by step documentation update process 1. Write the function reference in either R or C++ as described above You can use Roxygen and Doxygen to compile the reference written in the comments. Doxygen can be run using the doxywizard software. For Roxygen, the function roxygen2::roxygenize() will generate the function reference from the comments. Check that the function reference is correct. If not, correct it. Check that any vignettes or sample code that refer to your change are updated correctly. "],["glossary-1.html", "Glossary", " Glossary In this section we will define terms that come up throughout this handbook. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
